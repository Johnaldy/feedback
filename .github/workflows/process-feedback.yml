name: Process Partner Feedback

on:
  issues:
    types: [opened, edited]

jobs:
  process-feedback:
    # Only run on issues with the feedback label or title containing [Feedback]
    if: contains(github.event.issue.title, '[Feedback]') || contains(github.event.issue.labels.*.name, 'feedback')
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: write
      # This permission is required for updating project fields
      repository-projects: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Add feedback label if missing
        if: ${{ !contains(github.event.issue.labels.*.name, 'feedback') }}
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['feedback']
            })

      - name: Extract feedback data
        id: extract_data
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const body = issue.body;
            
            // Debug: Log raw issue body to understand its structure
            console.log('Raw issue body:');
            console.log('-----------------');
            console.log(body);
            console.log('-----------------');
            
            // Helper function to extract form fields with various formats
            function extractValue(fieldName, isNumber = false) {
              // Try multiple patterns to match various form formats
              const patterns = [
                // Form checkbox/dropdown selection format
                new RegExp(`${fieldName}.*?\\n.*?- (.*?)($|\\n)`, 's'),
                // Form input format
                new RegExp(`${fieldName}.*?\\n\\s*(.*?)($|\\n)`, 's'),
                // Key-value format
                new RegExp(`${fieldName}.*?: *(.*?)($|\\n)`, 's'),
                // GitHub form format with ###
                new RegExp(`### ${fieldName}\\s*\\r?\\n\\s*(.+?)(?=\\r?\\n###|$)`, 's'),
                // Direct match for numbers
                isNumber ? new RegExp(`${fieldName}[\\s\\S]*?(\\d+\\.?\\d*)`) : null
              ].filter(Boolean);
              
              for (const pattern of patterns) {
                const match = body.match(pattern);
                if (match && match[1]) {
                  const value = match[1].trim();
                  if (value && (!isNumber || !isNaN(parseFloat(value)))) {
                    return value;
                  }
                }
              }
              
              // Try extracting by form field ID
              const fieldIdMap = {
                'AVG Overall Customer Satisfaction': 'overall_satisfaction',
                'AVG Quality of Work/Material': 'quality_of_work',
                'AVG Effectiveness of Communication': 'communication',
                'AVG Impact/Value of Service': 'impact_value',
                'Partner Name': 'partner_name',
                'Engagement Type': 'engagement_type',
                'Date Completed': 'date_completed',
                'Vertical': 'vertical'
              };
              
              const fieldId = fieldIdMap[fieldName];
              if (fieldId) {
                const idPattern = new RegExp(`### ${fieldId}\\s*\\r?\\n\\s*(.+?)(?=\\r?\\n###|$)`, 's');
                const match = body.match(idPattern);
                if (match && match[1]) {
                  const value = match[1].trim();
                  if (value && (!isNumber || !isNaN(parseFloat(value)))) {
                    return value;
                  }
                }
              }
              
              return null;
            }
            
            // Extract ratings using the helper function
            const overallSatisfaction = extractValue('AVG Overall Customer Satisfaction', true);
            const qualityOfWork = extractValue('AVG Quality of Work/Material', true);
            const communication = extractValue('AVG Effectiveness of Communication', true);
            const impactValue = extractValue('AVG Impact/Value of Service', true);
            
            // Extract other fields
            const partnerName = extractValue('Partner Name');
            const engagementType = extractValue('Engagement Type');
            const dateCompleted = extractValue('Date Completed');
            const vertical = extractValue('Vertical');
            
            // Log extracted values for debugging
            console.log('Extracted values:');
            console.log(`Overall Satisfaction: ${overallSatisfaction}`);
            console.log(`Quality of Work: ${qualityOfWork}`);
            console.log(`Communication: ${communication}`);
            console.log(`Impact/Value: ${impactValue}`);
            console.log(`Partner Name: ${partnerName}`);
            console.log(`Engagement Type: ${engagementType}`);
            console.log(`Date Completed: ${dateCompleted}`);
            console.log(`Vertical: ${vertical}`);
            
            // Calculate CSAT score
            let csatScore = 0;
            let validRatings = 0;
            
            const addRating = (rating) => {
              if (rating) {
                const value = parseFloat(rating);
                if (!isNaN(value)) {
                  csatScore += value;
                  validRatings += 1;
                }
              }
            };
            
            addRating(overallSatisfaction);
            addRating(qualityOfWork);
            addRating(communication);
            addRating(impactValue);
            
            const finalCsatScore = validRatings > 0 ? (csatScore / validRatings).toFixed(2) : "N/A";
            console.log(`Final CSAT Score: ${finalCsatScore} (from ${validRatings} valid ratings)`);
            
            // Set outputs
            core.setOutput('csat_score', finalCsatScore);
            core.setOutput('partner_name', partnerName || "Unknown");
            core.setOutput('engagement_type', engagementType || "Unknown");
            core.setOutput('date_completed', dateCompleted || "Unknown");
            core.setOutput('vertical', vertical || "Unknown");

      - name: Add CSAT score comment
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const csatScore = '${{ steps.extract_data.outputs.csat_score }}';
            const partner = '${{ steps.extract_data.outputs.partner_name }}';
            const vertical = '${{ steps.extract_data.outputs.vertical }}';
            
            const comment = `## Feedback Analysis
            
            üìä **CSAT Score**: ${csatScore}
            üë• **Partner**: ${partner}
            üìÖ **Date Completed**: ${{ steps.extract_data.outputs.date_completed }}
            üìù **Engagement Type**: ${{ steps.extract_data.outputs.engagement_type }}
            üåé **Vertical**: ${vertical}
            
            *This analysis was automatically generated based on the feedback submission.*
            *Last processed: 2025-07-08 UTC*
            `;
            
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });
            
            // Update issue title to include CSAT score if not already there
            if (!context.payload.issue.title.includes('CSAT:')) {
              github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                title: `${context.payload.issue.title} [CSAT: ${csatScore}]`
              });
            }

      # Get project info to validate the project and fields exist
      - name: Validate project and fields
        id: validate_project
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const PROJECT_ID = 'PVT_kwHOAiZwz84A9bho';
            
            try {
              // First, verify the project exists and we have access
              const projectQuery = `
                query {
                  node(id: "${PROJECT_ID}") {
                    ... on ProjectV2 {
                      id
                      title
                      url
                      fields(first: 20) {
                        nodes {
                          ... on ProjectV2Field {
                            id
                            name
                          }
                          ... on ProjectV2IterationField {
                            id
                            name
                          }
                          ... on ProjectV2SingleSelectField {
                            id
                            name
                            options {
                              id
                              name
                            }
                          }
                        }
                      }
                    }
                  }
                }
              `;
              
              const projectResponse = await github.graphql(projectQuery, {
                headers: {
                  authorization: `token ${process.env.GITHUB_TOKEN}`
                }
              });
              
              console.log("Project info:");
              console.log(`Title: ${projectResponse.node.title}`);
              console.log(`URL: ${projectResponse.node.url}`);
              
              // Log all fields
              console.log("Available fields:");
              projectResponse.node.fields.nodes.forEach(field => {
                console.log(`- ${field.name}: ${field.id}`);
                if (field.options) {
                  console.log("  Options:");
                  field.options.forEach(option => {
                    console.log(`  - ${option.name}: ${option.id}`);
                  });
                }
              });
              
              core.setOutput('project_validated', 'true');
            } catch (error) {
              console.log(`Error validating project: ${error.message}`);
              console.log(error.stack);
              core.setOutput('project_validated', 'false');
            }

      - name: Add to project
        if: steps.validate_project.outputs.project_validated == 'true'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const PROJECT_ID = 'PVT_kwHOAiZwz84A9bho';
            
            // These IDs may need to be verified/updated based on the validate_project step output
            const CSAT_FIELD_ID = 'PVTF_lAHOAiZwz84A9bhozgxIpgg';
            const PARTNER_FIELD_ID = 'PVTSSF_lAHOAiZwz84A9bhozgxIpog';
            const ENGAGEMENT_TYPE_FIELD_ID = 'PVTSSF_lAHOAiZwz84A9bhozgxIqJk';
            const DATE_COMPLETED_FIELD_ID = 'PVTF_lAHOAiZwz84A9bhozgxIqNI';
            const STATUS_FIELD_ID = 'PVTSSF_lAHOAiZwz84A9bhozgxIooc';
            
            try {
              console.log('Starting project integration...');
              console.log(`Using Project ID: ${PROJECT_ID}`);
              console.log(`Issue Node ID: ${context.payload.issue.node_id}`);
              
              // Add the issue to the project
              const addToProjectMutation = `
                mutation {
                  addProjectV2ItemById(input: {
                    projectId: "${PROJECT_ID}"
                    contentId: "${context.payload.issue.node_id}"
                  }) {
                    item {
                      id
                    }
                  }
                }
              `;
              
              const addResponse = await github.graphql(addToProjectMutation, {
                headers: {
                  authorization: `token ${process.env.GITHUB_TOKEN}`
                }
              });
              
              const itemId = addResponse.addProjectV2ItemById.item.id;
              console.log(`Successfully added issue to project. Item ID: ${itemId}`);
              
              // Update the CSAT field
              if ('${{ steps.extract_data.outputs.csat_score }}' !== 'N/A') {
                try {
                  const csatValue = parseFloat('${{ steps.extract_data.outputs.csat_score }}') || 0;
                  console.log(`Setting CSAT field (${CSAT_FIELD_ID}) to: ${csatValue}`);
                  
                  const updateCsatMutation = `
                    mutation {
                      updateProjectV2ItemFieldValue(input: {
                        projectId: "${PROJECT_ID}"
                        itemId: "${itemId}"
                        fieldId: "${CSAT_FIELD_ID}"
                        value: {
                          number: ${csatValue}
                        }
                      }) {
                        projectV2Item {
                          id
                        }
                      }
                    }
                  `;
                  
                  await github.graphql(updateCsatMutation, {
                    headers: {
                      authorization: `token ${process.env.GITHUB_TOKEN}`
                    }
                  });
                  console.log(`Updated CSAT field for item ${itemId}`);
                } catch (e) {
                  console.log(`Error updating CSAT field: ${e.message}`);
                  console.log(e.stack);
                  
                  // Try a fallback approach for number fields
                  try {
                    console.log("Trying fallback approach for CSAT field");
                    const csatValue = parseFloat('${{ steps.extract_data.outputs.csat_score }}') || 0;
                    
                    const fallbackUpdateMutation = `
                      mutation {
                        updateProjectV2ItemFieldValue(input: {
                          projectId: "${PROJECT_ID}"
                          itemId: "${itemId}"
                          fieldId: "${CSAT_FIELD_ID}"
                          value: {
                            text: "${csatValue}"
                          }
                        }) {
                          projectV2Item {
                            id
                          }
                        }
                      }
                    `;
                    
                    await github.graphql(fallbackUpdateMutation, {
                      headers: {
                        authorization: `token ${process.env.GITHUB_TOKEN}`
                      }
                    });
                    console.log("Fallback CSAT update succeeded");
                  } catch (fallbackError) {
                    console.log(`Fallback CSAT update also failed: ${fallbackError.message}`);
                  }
                }
              }
              
              // Set Status to "New"
              try {
                // First get the options for the Status field
                console.log(`Getting options for Status field (${STATUS_FIELD_ID})`);
                const getStatusOptionsQuery = `
                  query {
                    node(id: "${PROJECT_ID}") {
                      ... on ProjectV2 {
                        field(id: "${STATUS_FIELD_ID}") {
                          ... on ProjectV2SingleSelectField {
                            options {
                              id
                              name
                            }
                          }
                        }
                      }
                    }
                  }
                `;
                
                const statusOptionsResponse = await github.graphql(getStatusOptionsQuery, {
                  headers: {
                    authorization: `token ${process.env.GITHUB_TOKEN}`
                  }
                });
                
                console.log("Status field options:", JSON.stringify(statusOptionsResponse.node.field.options));
                
                const statusOptions = statusOptionsResponse.node.field.options;
                // Look for "New" or similar status option
                const newStatusOption = statusOptions.find(option => 
                  option.name === "New" || option.name === "Todo" || option.name === "To Do"
                );
                
                if (newStatusOption) {
                  console.log(`Found status option: ${newStatusOption.name} (${newStatusOption.id})`);
                  const updateStatusMutation = `
                    mutation {
                      updateProjectV2ItemFieldValue(input: {
                        projectId: "${PROJECT_ID}"
                        itemId: "${itemId}"
                        fieldId: "${STATUS_FIELD_ID}"
                        value: {
                          singleSelectOptionId: "${newStatusOption.id}"
                        }
                      }) {
                        projectV2Item {
                          id
                        }
                      }
                    }
                  `;
                  
                  await github.graphql(updateStatusMutation, {
                    headers: {
                      authorization: `token ${process.env.GITHUB_TOKEN}`
                    }
                  });
                  console.log(`Set Status to "${newStatusOption.name}" for item ${itemId}`);
                } else {
                  console.log('Could not find appropriate Status option');
                }
              } catch (e) {
                console.log(`Error updating Status field: ${e.message}`);
                console.log(e.stack);
              }
              
              // Add Partner field - assuming it's a single select field
              const partnerName = '${{ steps.extract_data.outputs.partner_name }}';
              if (partnerName !== 'Unknown') {
                try {
                  console.log(`Setting Partner field to: "${partnerName}"`);
                  // First, we need to get the option ID for the partner name
                  const getOptionsQuery = `
                    query {
                      node(id: "${PROJECT_ID}") {
                        ... on ProjectV2 {
                          field(id: "${PARTNER_FIELD_ID}") {
                            ... on ProjectV2SingleSelectField {
                              options {
                                id
                                name
                              }
                            }
                          }
                        }
                      }
                    }
                  `;
                  
                  const optionsResponse = await github.graphql(getOptionsQuery, {
                    headers: {
                      authorization: `token ${process.env.GITHUB_TOKEN}`
                    }
                  });
                  
                  console.log("Partner field options:", JSON.stringify(optionsResponse.node.field.options));
                  
                  const options = optionsResponse.node.field.options;
                  
                  // Try to find an exact match first
                  let partnerOption = options.find(option => option.name === partnerName);
                  
                  // If no exact match, try case-insensitive match
                  if (!partnerOption) {
                    partnerOption = options.find(option => 
                      option.name.toLowerCase() === partnerName.toLowerCase()
                    );
                  }
                  
                  // If we found a matching option, update the field
                  if (partnerOption) {
                    console.log(`Found partner option: ${partnerOption.name} (${partnerOption.id})`);
                    const updatePartnerMutation = `
                      mutation {
                        updateProjectV2ItemFieldValue(input: {
                          projectId: "${PROJECT_ID}"
                          itemId: "${itemId}"
                          fieldId: "${PARTNER_FIELD_ID}"
                          value: {
                            singleSelectOptionId: "${partnerOption.id}"
                          }
                        }) {
                          projectV2Item {
                            id
                          }
                        }
                      }
                    `;
                    
                    await github.graphql(updatePartnerMutation, {
                      headers: {
                        authorization: `token ${process.env.GITHUB_TOKEN}`
                      }
                    });
                    console.log(`Updated Partner field for item ${itemId}`);
                  } else {
                    console.log(`Partner option "${partnerName}" not found in project options`);
                    console.log('Available partner options:');
                    options.forEach(opt => console.log(` - ${opt.name}`));
                  }
                } catch (e) {
                  console.log(`Error updating partner field: ${e.message}`);
                  console.log(e.stack);
                }
              }
              
              // Update Engagement Type field
              const engagementType = '${{ steps.extract_data.outputs.engagement_type }}';
              if (engagementType !== 'Unknown') {
                try {
                  console.log(`Setting Engagement Type field to: "${engagementType}"`);
                  // Get options for Engagement Type
                  const getEngagementOptionsQuery = `
                    query {
                      node(id: "${PROJECT_ID}") {
                        ... on ProjectV2 {
                          field(id: "${ENGAGEMENT_TYPE_FIELD_ID}") {
                            ... on ProjectV2SingleSelectField {
                              options {
                                id
                                name
                              }
                            }
                          }
                        }
                      }
                    }
                  `;
                  
                  const engagementOptionsResponse = await github.graphql(getEngagementOptionsQuery, {
                    headers: {
                      authorization: `token ${process.env.GITHUB_TOKEN}`
                    }
                  });
                  
                  console.log("Engagement Type field options:", JSON.stringify(engagementOptionsResponse.node.field.options));
                  
                  const engagementOptions = engagementOptionsResponse.node.field.options;
                  
                  // Try to find an exact match first
                  let engagementOption = engagementOptions.find(option => option.name === engagementType);
                  
                  // If no exact match, try case-insensitive match
                  if (!engagementOption) {
                    engagementOption = engagementOptions.find(option => 
                      option.name.toLowerCase() === engagementType.toLowerCase()
                    );
                  }
                  
                  if (engagementOption) {
                    console.log(`Found engagement option: ${engagementOption.name} (${engagementOption.id})`);
                    const updateEngagementMutation = `
                      mutation {
                        updateProjectV2ItemFieldValue(input: {
                          projectId: "${PROJECT_ID}"
                          itemId: "${itemId}"
                          fieldId: "${ENGAGEMENT_TYPE_FIELD_ID}"
                          value: {
                            singleSelectOptionId: "${engagementOption.id}"
                          }
                        }) {
                          projectV2Item {
                            id
                          }
                        }
                      }
                    `;
                    
                    await github.graphql(updateEngagementMutation, {
                      headers: {
                        authorization: `token ${process.env.GITHUB_TOKEN}`
                      }
                    });
                    console.log(`Updated Engagement Type field for item ${itemId}`);
                  } else {
                    console.log(`Engagement Type option "${engagementType}" not found in project options`);
                    console.log('Available engagement type options:');
                    engagementOptions.forEach(opt => console.log(` - ${opt.name}`));
                  }
                } catch (e) {
                  console.log(`Error updating engagement type field: ${e.message}`);
                  console.log(e.stack);
                }
              }
              
              // Update Date Completed field
              const dateCompleted = '${{ steps.extract_data.outputs.date_completed }}';
              if (dateCompleted !== 'Unknown') {
                try {
                  console.log(`Setting Date Completed field to: "${dateCompleted}"`);
                  const updateDateMutation = `
                    mutation {
                      updateProjectV2ItemFieldValue(input: {
                        projectId: "${PROJECT_ID}"
                        itemId: "${itemId}"
                        fieldId: "${DATE_COMPLETED_FIELD_ID}"
                        value: {
                          date: "${dateCompleted}"
                        }
                      }) {
                        projectV2Item {
                          id
                        }
                      }
                    }
                  `;
                  
                  await github.graphql(updateDateMutation, {
                    headers: {
                      authorization: `token ${process.env.GITHUB_TOKEN}`
                    }
                  });
                  console.log(`Updated Date Completed field for item ${itemId}`);
                } catch (e) {
                  console.log(`Error updating date field: ${e.message}`);
                  console.log(e.stack);
                  
                  // Try a fallback approach for date fields
                  try {
                    console.log("Trying fallback approach for date field");
                    const fallbackDateMutation = `
                      mutation {
                        updateProjectV2ItemFieldValue(input: {
                          projectId: "${PROJECT_ID}"
                          itemId: "${itemId}"
                          fieldId: "${DATE_COMPLETED_FIELD_ID}"
                          value: {
                            text: "${dateCompleted}"
                          }
                        }) {
                          projectV2Item {
                            id
                          }
                        }
                      }
                    `;
                    
                    await github.graphql(fallbackDateMutation, {
                      headers: {
                        authorization: `token ${process.env.GITHUB_TOKEN}`
                      }
                    });
                    console.log("Fallback date update succeeded");
                  } catch (fallbackError) {
                    console.log(`Fallback date update also failed: ${fallbackError.message}`);
                  }
                }
              }
              
            } catch (error) {
              console.log(`Error in project integration: ${error.message}`);
              console.log(error.stack);
            }
